package Task

// standard imports
import HashMap
import HashList
import Event
import ClosureTimers
import TimerUtils

// custom imports
import Common
import Hero
import Award
import ColorUtils
import TriggerClosure

/*
 * Generally, there are three kinds of tasks in the game, including tasks that need player kill creeps, 
 * tasks that need player get some kinds of items, and tasks that need to visit some npcs.
 */

/* task type constants */

public let TASK_TYPE_KILLING = 0

public let TASK_TYPE_COLLECTING = 1

public let TASK_TYPE_VISITING = 2

/* task id constants */

/* task condition type */
public let CONDITION_TYPE_LEVEL = 0

public let CONDITION_TYPE_REPUTATION = 1

public let CONDITION_TYPE_PRACTICE = 2

public interface TaskHandler
    function onCompleteTask(Task whichTask)
    function isCompleted(Task whichTask) returns bool
    function showProgress(Task whichTask)
    function giveAwards(Task whichTask)


public class KillingTaskHandler implements TaskHandler
    IterableMap<int, int> killCounter = new IterableMap<int, int>()
    function onCompleteTask(Task whichTask)
        let u = GetTriggerUnit()
        // the dying creep id is not in the task killing list.
        if not whichTask.killCreepMap.hasKey(u.getTypeId())
            return

        if isCompleted(whichTask)
            giveAwards(whichTask)
            whichTask.hero.doneTasks.add(whichTask)
            whichTask.hero.ongoingTasks.remove(whichTask)
        else
            showProgress(whichTask)        
        
    /** checks whether the killing task is completed **/
    function isCompleted(Task whichTask) returns bool
        HLIterator<int> iterator = whichTask.killCreepMap.iterator()
        while iterator.hasNext()
            var key = iterator.next()
            if not killCounter.hasKey(key) or killCounter.get(key) < whichTask.killCreepMap.get(key)
                return false
        return true
    
    /** shows the progress of the killing task **/
    function showProgress(Task whichTask)
        let p = whichTask.hero.u.getOwner()
        HLIterator<int> iterator = whichTask.killCreepMap.iterator()
        while iterator.hasNext()
            var unitId = iterator.next()
            var unitName = GetObjectName(unitId)
            var finishedCount = killCounter.get(unitId)
            var totalCount = whichTask.killCreepMap.get(unitId)
            printTimedToPlayer(ColorUtils.IN_PROGRESS + unitName + ": " + finishedCount.toString() + " / " + totalCount.toString(), 10, p)
    
    function giveAwards(Task whichTask)
        HLIterator<Award> iterator = whichTask.awardList.iterator()
        while iterator.hasNext()
            Award award = iterator.next()
            whichTask.hero.addAward(award, true)

    ondestroy
        destroy killCounter

/** the pre-conditions of a task **/
public class TaskCondition
    
    bool condition

    /** If the condition is not met, show the description to the hero **/
    string conditionDescription

    construct(bool condition, string conditionDescription)
        this.condition = condition
        this.conditionDescription = conditionDescription

public class Task
    /** the subject of the task **/
    Hero hero 

    /** the type of the task **/
    int taskType 

    /** the unique identification of different kind of task **/
    int taskId

    /** 0-ongoing 1-success 2-fail**/
    int status = 0
    
    /** used as the title in time dialog **/
    string taskName

    /** the description of the task **/
    string taskDescription
    
    /** the pre-conditions of the task **/
    HashList<TaskCondition> conditions

    /** If the task type is killing creep, this field saves the type and number of creeps to kill. **/
    IterableMap<int, int> killCreepMap

    /** If the task type is collecting items, this field saves the type and number of items to collect. **/
    IterableMap<int, int> collectItemMap
    
    /** If the task type is visiting npc, this field saves which position to enter, needs to provide 
     *  `vec2ToIndex` and `vec2FromIndex` functions.
     */
    HashList<unit> visitList   

    /**
     * saves the awards given to the hero if the task is completed.
     */
    HashList<Award> awardList
     
    /** If the task is time-limited, this field tells the time limitation (in seconds). 
     * If the value equals to -1 (default value), it means the task is not time-limited.
     */
    int period = -1
    
    /** the permitted repeat times of the task. If the value equals to -1,
    * it means the task has no repeat times limit.
    */
    int repeatTimes = -1
    
    /**
     * save the position to perform the task if the task needs a Teleport
     */
    vec2 taskPos = vec2(0, 0)

    /**
     * The handler handles the event that completes the task
     */
    TaskHandler handler
    
    /** listener that listens the task completing event **/
    EventListener listener

    trigger trig

    construct(Hero hero, int taskType, int taskId, string taskDescription, IterableMap<int, int> map, HashList<Award> awardList, TaskHandler handler)
        this.hero = hero
        this.taskType = taskType
        this.taskId = taskId
        this.taskDescription = taskDescription
        this.awardList = awardList
        this.handler = handler
        this.hero.ongoingTasks.add(this) 
        if taskType == TASK_TYPE_KILLING
            this.killCreepMap = map
            this.listener = EventListener.add(EVENT_PLAYER_UNIT_DEATH, ()-> handler.onCompleteTask(this))
        else if taskType == TASK_TYPE_COLLECTING
            this.collectItemMap = map
    
    construct(Hero hero, int taskType, int taskId, string taskDescription, HashList<unit> visitList, HashList<Award> awardList, TaskHandler handler)
        this.hero = hero
        this.taskType = taskType
        this.taskId = taskId
        this.taskDescription = taskDescription
        this.awardList = awardList
        this.handler = handler
        this.hero.ongoingTasks.add(this) 
        this.visitList = visitList
        this.trig = CreateTrigger()
        for u in visitList
            this.trig.registerUnitInRangeSource(u, 256)
        this.trig.addActionClosure(() -> this.handler.onCompleteTask(this))
            
    function setTaskName(string taskName)
        this.taskName = taskName

    function setPeriod(int period)
        this.period = period
        var t = getTimer()..start(period.toReal(), null)
        var title = "任务倒计时："
        if this.taskName != null
            title = this.taskName + "倒计时："
        var td = CreateTimerDialogBJ(t, title)
        TimerDialogDisplayForPlayerBJ(true, td, this.hero.u.getOwner())
        doAfter(period.toReal()) ->
            if this.status == 0
                printTimedToPlayer(ColorUtils.FAIL +  "时间到，任务失败", 15, this.hero.u.getOwner())
                DestroyTimerDialog(td)
                destroy this

    
    function setRepeatTimes(int repeatTimes)
        this.repeatTimes = repeatTimes
    
    function setTaskPos(vec2 taskPos)
        this.taskPos = taskPos
    
    ondestroy
        this.hero.ongoingTasks.remove(this)
        destroy this.handler
        destroy listener
        this.trig.destr()

public function evaluateTaskConditions(HashList<TaskCondition> conditions, Hero hero) returns bool
    HLIterator<TaskCondition> iterator = conditions.iterator()
    while iterator.hasNext()
        TaskCondition condition = iterator.next()
        if not condition.condition
            printTimedToPlayer(ColorUtils.WARNING + condition.conditionDescription, 15, hero.u.getOwner())
            return false
    return true
    

    