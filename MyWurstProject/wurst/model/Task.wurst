package Task

// standard imports
import HashMap
import HashList
import Event

// custom imports
import Common
import Hero
import Award
import ColorUtils

/*
 * Generally, there are three kinds of tasks in the game, including tasks that need player kill creeps, 
 * tasks that need player get some kinds of items, and tasks that need to visit some npcs.
 */

/* task type constants */

public let TASK_TYPE_KILLING = 0

public let TASK_TYPE_COLLECTING = 1

public let TASK_TYPE_VISITING = 2

/* task id constants */

/* task condition type */
public let CONDITION_TYPE_LEVEL = 0

public let CONDITION_TYPE_REPUTATION = 1

public let CONDITION_TYPE_PRACTICE = 2

public interface TaskHandler
    function onCompleteTask(Task whichTask)
    function isCompleted(Task whichTask) returns bool
    function showProgress(Task whichTask)
    function giveAwards(Task whichTask)


public class KillingTaskHandler implements TaskHandler
    IterableMap<int, int> killCounter = new IterableMap<int, int>()
    function onCompleteTask(Task whichTask)
        let u = GetTriggerUnit()
        // the dying creep id is not in the task killing list.
        if not whichTask.killCreepMap.hasKey(u.getTypeId())
            return

        if isCompleted(whichTask)
            giveAwards(whichTask)
        else
            showProgress(whichTask)        
        
    /** checks whether the killing task is completed **/
    function isCompleted(Task whichTask) returns bool
        HLIterator<int> iterator = whichTask.killCreepMap.iterator()
        while iterator.hasNext()
            var key = iterator.next()
            if not killCounter.hasKey(key) or killCounter.get(key) < whichTask.killCreepMap.get(key)
                return false
        return true
    
    /** shows the progress of the killing task **/
    function showProgress(Task whichTask)
        let p = whichTask.hero.u.getOwner()
        HLIterator<int> iterator = whichTask.killCreepMap.iterator()
        while iterator.hasNext()
            var unitId = iterator.next()
            var unitName = GetObjectName(unitId)
            var finishedCount = killCounter.get(unitId)
            var totalCount = whichTask.killCreepMap.get(unitId)
            printTimedToPlayer(ColorUtils.IN_PROGRESS + unitName + ": " + finishedCount.toString() + " / " + totalCount.toString(), 10, p)
    
    function giveAwards(Task whichTask)
        HLIterator<Award> iterator = whichTask.awardList.iterator()
        while iterator.hasNext()
            Award award = iterator.next()
            whichTask.hero.addAward(award, true)

    ondestroy
        destroy killCounter

/** the pre-conditions of a task **/
public class TaskCondition
    
    bool condition

    /** If the condition is not met, show the description to the hero **/
    string conditionDescription

    construct(bool condition, string conditionDescription)
        this.condition = condition
        this.conditionDescription = conditionDescription

public class Task
    /** the subject of the task **/
    Hero hero 

    /** the type of the task **/
    int taskType 

    /** the unique identification of the task **/
    int taskId
    
    /** the description of the task **/
    string taskDescription
    
    /** the pre-conditions of the task **/
    HashList<TaskCondition> conditions

    /** If the task type is killing creep, this field saves the type and number of creeps to kill. **/
    IterableMap<int, int> killCreepMap

    /** If the task type is collecting items, this field saves the type and number of items to collect. **/
    IterableMap<int, int> collectItemMap
    
    /** If the task type is visiting npc, this field saves which position to enter, needs to provide 
     *  `vec2ToIndex` and `vec2FromIndex` functions.
     */
    HashList<int> visitList   

    /**
     * saves the awards given to the hero if the task is completed.
     */
    HashList<Award> awardList
     
    /** If the task is time-limited, this field tells the time limitation (in seconds). 
     * If the value equals to -1 (default value), it means the task is not time-limited.
     */
    int period = -1
    
    /** the permitted repeat times of the task. If the value equals to -1,
    * it means the task has no repeat times limit.
    */
    int repeatTimes = -1
    
    /**
     * save the position to perform the task if the task needs a Teleport
     */
    vec2 taskPos = vec2(0, 0)

    /**
     * The handler handles the event that completes the task
     */
    TaskHandler handler

    construct(Hero hero, int taskType, int taskId, string taskDescription, HashList<TaskCondition> conditions, IterableMap<int, int> killCreepMap, HashList<Award> awardList, TaskHandler handler)
        this.hero = hero
        this.taskType = taskType
        this.taskId = taskId
        this.taskDescription = taskDescription
        this.conditions = conditions
        this.killCreepMap = killCreepMap
        this.awardList = awardList
        this.handler = handler
        HLIterator<TaskCondition> iterator = conditions.iterator()
        while iterator.hasNext()
            TaskCondition condition = iterator.next()
            if not condition.condition
                printTimedToPlayer(ColorUtils.WARNING + condition.conditionDescription, 15, hero.u.getOwner())
                
        this.hero.ongoingTasks.add(this)        
        EventListener.add(EVENT_PLAYER_UNIT_DEATH, ()-> handler.onCompleteTask(this))
    
    function setPeriod(int period)
        this.period = period
    
    function setRepeatTimes(int repeatTimes)
        this.repeatTimes = repeatTimes
    
    function setTaskPos(vec2 taskPos)
        this.taskPos = taskPos
    
    ondestroy
        this.hero.ongoingTasks.remove(this)
        destroy this.handler
        
    

    